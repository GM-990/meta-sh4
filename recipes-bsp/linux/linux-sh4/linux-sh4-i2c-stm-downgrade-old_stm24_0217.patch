diff -Naur linux-sh4-2.6.32.71-stmicro/drivers/i2c/busses/i2c-stm.c linux-sh4-2.6.32.71-stmicro-PersianPrince/drivers/i2c/busses/i2c-stm.c
--- linux-sh4-2.6.32.71-stmicro/drivers/i2c/busses/i2c-stm.c	2018-09-22 20:27:39.000000000 +0330
+++ linux-sh4-2.6.32.71-stmicro-PersianPrince/drivers/i2c/busses/i2c-stm.c	2019-12-10 14:15:41.540480503 +0330
@@ -161,7 +161,6 @@
 
 enum iic_state_machine {
 	IIC_FSM_VOID = 0,
-	IIC_FSM_IDLE,
 	IIC_FSM_PREPARE,
 	IIC_FSM_NOREPSTART,
 	IIC_FSM_START,
@@ -210,7 +209,6 @@
 
 struct iic_ssc {
 	void __iomem *base;
-	struct clk *clk;
 	struct iic_transaction *trns;
 	struct i2c_adapter adapter;
 	unsigned long config;
@@ -237,7 +235,7 @@
 
 #define clear_ready_fastmode(adap) ((adap)->config &= ~IIC_STM_READY_SPEED_FAST)
 
-static void iic_stm_setup_timing(struct iic_ssc *adap);
+static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long rate);
 
 static irqreturn_t iic_state_machine(int this_irq, void *data)
 {
@@ -257,7 +255,6 @@
 	} tmp;
 	unsigned short txbuff[SSC_TXFIFO_SIZE];
 	unsigned int txbuffcount;
-	unsigned int cnt = 0;
 
 	fast_mode = check_fastmode(adap);
 	pmsg = trsc->msgs_queue + trsc->current_msg;
@@ -314,7 +311,9 @@
 		 */
 		if ((check_fastmode(adap) && !check_ready_fastmode(adap)) ||
 		    (!check_fastmode(adap) && check_ready_fastmode(adap)))
-			iic_stm_setup_timing(adap);
+			iic_stm_setup_timing(adap,
+					     clk_get_rate(clk_get
+							  (NULL, "comms_clk")));
 
 		trsc->start_state = IIC_FSM_START;
 
@@ -409,14 +408,6 @@
 	case IIC_FSM_REPSTART_ADDR:
 		dbg_print2("-Rep Start addr 0x%x\n", pmsg->addr);
 
-		/* Check that slave is not doing a clock stretch */
-		while (((ssc_load32(adap, SSC_STA) & SSC_STA_CLST)
-					!= SSC_STA_CLST) && (cnt++ < 1000))
-			ndelay(100);
-
-		if (cnt >= 1000)
-			jump_on_fsm_abort(trsc);
-
 		/* Clear NACK */
 		ssc_store32(adap, SSC_CLR, 0xdc0);
 
@@ -558,7 +549,7 @@
 		trsc->status_error |= IIC_E_NOTACK;
 
 		ssc_store32(adap, SSC_CLR, 0xdc0);
-		trsc->next_state = IIC_FSM_IDLE;
+		trsc->next_state = IIC_FSM_COMPLETE;
 
 		ssc_store32(adap, SSC_IEN, SSC_IEN_STOPEN | SSC_IEN_ARBLEN);
 		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_STOPG |
@@ -596,7 +587,7 @@
 		} else {
 			/* stop */
 			dbg_print2(" STOP - STOP\n");
-			trsc->next_state = IIC_FSM_IDLE;
+			trsc->next_state = IIC_FSM_COMPLETE;
 			ssc_store32(adap, SSC_I2C,
 				    SSC_I2C_I2CM | SSC_I2C_TXENB |
 				    SSC_I2C_STOPG | SSC_I2C_I2CFSMODE);
@@ -605,20 +596,6 @@
 		}
 
 		break;
-	case IIC_FSM_IDLE:
-		/* In Idle state the SSC still remains
-		 * in I2C mode but with the SSC_CTL.Master mode disabled.
-		 * In this configuration it seems much more stable
-		 * during a plugging/unplugging of HDMI-cable
-		 * i.e.: it is much less sensible to the noice on the cable
-		 */
-		dbg_print2("-Idle\n");
-		/* push the data line high */
-		ssc_store32(adap, SSC_TBUF, 0x1ff);
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_I2CFSMODE);
-		ssc_store32(adap, SSC_CTL, SSC_CTL_EN |
-			    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
-		/* No break here! */
 	case IIC_FSM_COMPLETE:
 		dbg_print2("-Complete\n");
 
@@ -975,7 +952,7 @@
 }
 #endif
 
-static void iic_stm_setup_timing(struct iic_ssc *adap)
+static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long clock)
 {
 	unsigned long iic_baudrate;
 	unsigned short iic_rep_start_hold;
@@ -991,9 +968,9 @@
 	unsigned char iic_prescaler;
 	unsigned short iic_prescaler_dataout;
 #endif
-	unsigned long ns_per_clk, clock ;
+	unsigned long ns_per_clk;
 
-	clock = clk_get_rate(adap->clk) + 500000; /* +0.5 Mhz for rounding */
+	clock += 500000;	/* +0.5 Mhz for rounding */
 	dbg_print("Assuming %lu MHz for the Timing Setup\n", clock / 1000000);
 
 	ns_per_clk = NANOSEC_PER_SEC / clock;
@@ -1188,15 +1165,7 @@
 	i2c_stm->adapter.dev.parent = &(pdev->dev);
 	if (plat_data->i2c_fastmode)
 		i2c_stm->config = IIC_STM_CONFIG_SPEED_FAST;
-	i2c_stm->clk = clk_get(&(pdev->dev), "comms_clk");
-	if (!i2c_stm->clk) {
-		dev_err(&pdev->dev, "Comms clock not found!\n");
-		return -ENODEV;
-	}
-
-	clk_enable(i2c_stm->clk);
-
-	iic_stm_setup_timing(i2c_stm);
+	iic_stm_setup_timing(i2c_stm, clk_get_rate(clk_get(NULL, "comms_clk")));
 	init_waitqueue_head(&(i2c_stm->wait_queue));
 	if (i2c_add_numbered_adapter(&(i2c_stm->adapter)) < 0) {
 		dev_err(&pdev->dev, "I2C core refuses the i2c/stm adapter\n");
@@ -1222,8 +1191,6 @@
 	struct resource *res;
 	struct iic_ssc *iic_stm = platform_get_drvdata(pdev);
 
-	clk_disable(iic_stm->clk);
-
 	i2c_del_adapter(&iic_stm->adapter);
 	/* irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
@@ -1251,7 +1218,6 @@
 #endif
 	ssc_store32(i2c_bus, SSC_IEN, 0);
 	ssc_store32(i2c_bus, SSC_CTL, 0);
-	clk_disable(i2c_bus->clk);
 
 	return 0;
 }
@@ -1271,12 +1237,11 @@
 		stpio_configure_pin(pio_info->sdout, STPIO_ALT_BIDIR);
 	}
 #endif
-	clk_enable(i2c_bus->clk);
 	/* enable RX, TX FIFOs - clear SR bit */
 	ssc_store32(i2c_bus, SSC_CTL, SSC_CTL_EN |
 		    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
 	ssc_store32(i2c_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_I2CFSMODE);
-	iic_stm_setup_timing(i2c_bus);
+	iic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL, "comms_clk")));
 	return 0;
 }
 #else
