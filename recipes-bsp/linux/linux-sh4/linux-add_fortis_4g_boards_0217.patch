--- a/arch/sh/boards/Kconfig.orig
+++ b/arch/sh/boards/Kconfig
@@ -795,7 +801,71 @@
 	  Select SH_ST_MB903 if configuring for a
 	  STMicroelectronics STi7108M Reference Board.
 
-comment "ST Peripheral Boards"
+config SH_FORTIS_DP2010
+	bool "DP2010: Fortis DP2010 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP2010 if configuring for a
+	  Fortis DP2010 board.
+
+config SH_FORTIS_DP7000
+	bool "DP7000: Fortis DP7000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP7000 if configuring for a
+	  Fortis DP7000 board.
+
+config SH_FORTIS_DP7001
+	bool "DP7001: Fortis DP7001 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP7001 if configuring for a
+	  Fortis DP7001 board.
+
+config SH_FORTIS_DP7050
+	bool "DP7050: Fortis DP7050 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP7050 if configuring for a
+	  Fortis DP7050 board.
+
+config SH_FORTIS_EP8000
+	bool "EP8000: Fortis EP8000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_EP8000 if configuring for a
+	  Fortis EP8000 board.
+
+config SH_FORTIS_EPP8000
+	bool "EPP8000: Fortis EPP8000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_EPP8000 if configuring for a
+	  Fortis EPP8000 board.
+
+config SH_FORTIS_FX6010
+	bool "FX6010: Fortis FX6010 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_FX6010 if configuring for a
+	  Fortis FX6010 board.
+
+config SH_FORTIS_GPV8000
+	bool "GPV8000: Fortis GPV8000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_GPV8000 if configuring for a
+	  Fortis GPV8000 board.
+
+comment "ST Peripheral Boards"
 
 config SH_ST_DB641
 	bool "db641: STEM board with double SMSC LAN9117 Ethernet interface"
--- a/arch/sh/boards/mach-dp2010/Makefile.orig
+++ b/arch/sh/boards/mach-dp2010/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP2010 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp2010/setup.c.orig
+++ b/arch/sh/boards/mach-dp2010/setup.c
@@ -0,0 +1,527 @@
+/*
+ * arch/sh/boards/mach-dp2010/setup.c
+ *
+ * Modified for Fortis DP2010 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP2010_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define DP2010_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 //TODO: get correct value
+
+// DP2010 specific changes
+#define DP2010_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - companion 0? (4mb) 
+0x40400000 - 0x404fffff - companion 1? (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x42dd1fff - bigphys ( 30mb)
+//0x4A000000 - 0x4FBFFFFF - lmi_io  ( 92mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x40fd2000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x4a000000,
+		.size  = 0x20000000,  /* 92 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init dp2010_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP2010 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN703
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led dp2010_led[] =
+{
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7),
+	}
+};
+ 
+static struct gpio_led_platform_data dp2010_led_data =
+{
+	.num_leds = ARRAY_SIZE(dp2010_led),
+	.leds     = dp2010_led,
+};
+
+static struct platform_device dp2010_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &dp2010_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key dp2010_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character dp2010_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device dp2010_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 1, // all LEDs off, blue on
+
+		.keys_num         = ARRAY_SIZE(dp2010_front_panel_keys),
+		.keys             = dp2010_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(dp2010_front_panel_characters),
+		.characters       = dp2010_front_panel_characters
+		.text             = "DP2010",
+	},
+};
+
+static struct gpio_keys_button dp2010_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = DP2010_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device dp2010_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &dp2010_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The DP2010 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data dp2010_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp2010_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP2010_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP2010_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp2010_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *dp2010_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&dp2010_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&dp2010_keys,
+	&dp2010_front_panel,
+ 	&dp2010_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+//	int i, j;
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP2010_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP2010_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP2010_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP2010_POWER_ON, 0);
+
+	gpio_request(DP2010_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP2010_HDMI);
+	
+#if 0
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 4; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (j <> 2)
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d,%1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCDL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCDL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+#if 0
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCDL:2.6, SDA:2.7
+	});
+#endif
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+#if defined(CONFIG_LIRC_STM_UHF)
+		.rx_mode       = stxh205_lirc_rx_mode_uhf,
+#else
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+#endif
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp2010_nand_flash,
+		.rbn.flex_connected = 1,
+//		.bch_ecc_cfg        = BCH_ECC_CFG_NOECC
+	});
+
+	return platform_add_devices(dp2010_devices, ARRAY_SIZE(dp2010_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *dp2010_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv =
+{
+	.mv_name = "dp2010",
+	.mv_setup = dp2010_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = dp2010_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(void)
+{
+	gpio_set_value(DP2010_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(void)
+{
+	dp2010_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom =
+{
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-dp7000/Makefile.orig
+++ b/arch/sh/boards/mach-dp7000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP7000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp7000/setup.c.orig
+++ b/arch/sh/boards/mach-dp7000/setup.c
@@ -0,0 +1,519 @@
+/*
+ * arch/sh/boards/mach-dp7000/setup.c
+ *
+ * Modified for Fortis DP7000 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP7000_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define DP7000_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 // TODO: get correct value
+
+// DP7000 specific changes
+#define DP7000_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+//#define SMARTCARD1_0             stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1             stm_gpio(11, 1)
+
+//#if 0
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init dp7000_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP7000 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN702
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led dp7000_led[] =
+{
+	{
+		.name = "LED_RED",
+		.gpio = stm_gpio(15, 7),  // TODO: find correct PIO number
+	}
+};
+
+static struct gpio_led_platform_data dp7000_led_data =
+{
+	.num_leds = ARRAY_SIZE(dp7000_led),
+	.leds     = dp7000_led,
+};
+
+static struct platform_device dp7000_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &dp7000_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key dp7000_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character dp7000_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device dp7000_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(dp7000_front_panel_keys),
+		.keys             = dp7000_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(dp7000_front_panel_characters),
+		.characters       = dp7000_front_panel_characters
+		.text             = "DP7000",
+	},
+};
+
+static struct gpio_keys_button dp7000_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = DP7000_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device dp7000_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &dp7000_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The DP7000 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data dp7000_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp7000_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP7000_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP7000_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp7000_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *dp7000_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&dp7000_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&dp7000_keys,
+	&dp7000_front_panel,
+ 	&dp7000_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP7000_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP7000_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP7000_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP7000_POWER_ON, 0);
+
+	// jdc1004 '13.07.30 HW request, change to input mode
+	gpio_request(DP7000_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP7000_HDMI);
+	
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+//	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp7000_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(dp7000_devices, ARRAY_SIZE(dp7000_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *dp7000_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv =
+{
+	.mv_name = "dp7000",
+	.mv_setup = dp7000_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = dp7000_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(void)
+{
+	gpio_set_value(DP7000_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(void)
+{
+	dp7000_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom =
+{
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-dp7001/Makefile.orig
+++ b/arch/sh/boards/mach-dp7001/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP7001 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp7001/setup.c.orig
+++ b/arch/sh/boards/mach-dp7001/setup.c
@@ -0,0 +1,536 @@
+/*
+ * arch/sh/boards/mach-dp7001/setup.c
+ *
+ * Modified for Fortis DP7001 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET6226)
+#include <linux/et6226.h>
+#endif
+#include <linux/bpa2.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP7001_GPIO_FLASH_WP       stm_gpio(6, 2)
+//#ifndef CONFIG_SH_ST_B2067C_BOARD
+//#define DP7001_GPIO_POWER_ON_ETH   stm_gpio(2, 5)
+//#else
+#define DP7001_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define DP7001_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1  // TODO: get correct value
+
+// DP7001 specific changes
+#define DP7001_HDMI               stm_gpio(2, 5)
+//#define SMARTCARD1_0              stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1              stm_gpio(11, 1)
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init dp7001_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP7001 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART_SW: On board JST connector CN701
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+			.hw_flow_control = 0,
+			.is_console = 1,
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led dp7001_led[] =
+{
+//	{
+//		.name = "LED_RED",
+//		.gpio = stm_gpio(15, 6),  // TODO: find correct PIO number
+//	},
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7)
+	}
+};
+
+static struct gpio_led_platform_data dp7001_led_data =
+{
+	.num_leds = ARRAY_SIZE(dp7001_led),
+	.leds     = dp7001_led,
+};
+
+static struct platform_device dp7001_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &dp7001_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET6226)
+static struct et6226_key dp7001_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+//	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+//	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et6226_character dp7001_front_panel_characters[] =
+{
+	ET6226_7_SEG_ASCII
+};
+
+static struct platform_device dp7001_front_panel =
+{
+	.name = "et6226",
+	.id = -1,
+	.dev.platform_data = &(struct et6226_platform_data)
+	{
+//		.gpio_din         = ET16315_DIN,
+//		.gpio_dout        = ET16315_DOUT,
+//		.gpio_clk         = ET16315_CLK,
+//		.gpio_stb         = ET16315_STB,
+		.digits           = 4,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(dp7001_front_panel_keys),
+		.keys             = dp7001_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(dp7001_front_panel_characters),
+		.characters       = dp7001_front_panel_characters
+		.text             = "7001",
+	},
+};
+
+static struct gpio_keys_button dp7001_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = DP7001_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device dp7001_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &dp7001_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif  // INPUT_ET6226
+
+
+/* NAND Flash */
+/* The DP7001 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data dp7001_nand_flash =
+{
+	.csn            = 0,
+	.options        = NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions  = 9,
+	.partitions     = (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec    = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp7001_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appear
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP7001_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP7001_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp7001_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25), /* MDINT */
+};
+
+static struct platform_device *dp7001_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&dp7001_leds,
+#endif
+#if defined(INPUT_ET6226)
+	&dp7001_front_panel,
+	&dp7001_fp_gpio_keys
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the various PIO's */
+#define SLEEP 500
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 2 && j == 6) || (i == 2 && j == 7) || (i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP7001_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP7001_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP7001_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP7001_POWER_ON, 0);
+
+	// jdc1004 '13.07.30 HW request, change to input mode
+	gpio_request(DP7001_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP7001_HDMI);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode = stxh205_ethernet_mode_mii,
+		.ext_clk = 1,
+		.phy_bus = 0,
+		.phy_addr = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+//	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1,
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6,
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCL:2.6, SDA:2.7
+//		.routing.ssc5.sclk = stxh205_ssc5_sclk_pio2_6,
+//		.routing.ssc5.mtsr = stxh205_ssc5_mtsr_pio2_7
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc = 0,
+		.no_mmc_boot_data_error = 1,
+	});
+
+#if 0
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(DP7001_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(DP7001_GPIO_FLASH_WP, 1);
+#endif
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp7001_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(dp7001_devices, ARRAY_SIZE(dp7001_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *dp7001_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv = {
+	.mv_name = "dp7001",
+	.mv_setup = dp7001_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = dp7001_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+//static int dp7001_board_freeze(struct stm_wakeup_devices *wkd)
+static int dp7001_board_freeze(void)
+{
+//	if (!wkd->stm_mac0_can_wakeup)
+		gpio_set_value(DP7001_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+//static int dp7001_board_defrost(struct stm_wakeup_devices *wkd)
+static int dp7001_board_defrost(void)
+{
+	dp7001_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board dp7001_hom =
+{
+	.freeze = dp7001_board_freeze,
+	.restore = dp7001_board_defrost,
+};
+
+static int __init dp7001_hom_register(void)
+{
+	return stm_hom_board_register(&dp7001_hom);
+}
+
+module_init(dp7001_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-dp7050/Makefile.orig
+++ b/arch/sh/boards/mach-dp7050/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP7050 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp7050/setup.c.orig
+++ b/arch/sh/boards/mach-dp7050/setup.c
@@ -0,0 +1,536 @@
+/*
+ * arch/sh/boards/mach-dp7050/setup.c
+ *
+ * Modified for Fortis DP7050 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET6226)
+#include <linux/et6226.h>
+#endif
+#include <linux/bpa2.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP7050_GPIO_FLASH_WP       stm_gpio(6, 2)
+//#ifndef CONFIG_SH_ST_B2067C_BOARD
+//#define DP7050_GPIO_POWER_ON_ETH   stm_gpio(2, 5)
+//#else
+#define DP7050_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define DP7050_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1  // TODO: get correct value
+
+// DP7050 specific changes
+#define DP7050_HDMI               stm_gpio(2, 5)
+//#define SMARTCARD1_0              stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1              stm_gpio(11, 1)
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init dp7050_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP7050 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART_SW: On board JST connector CN701
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+			.hw_flow_control = 0,
+			.is_console = 1,
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led dp7050_led[] =
+{
+//	{
+//		.name = "LED_RED",
+//		.gpio = stm_gpio(15, 6),  // TODO: find correct PIO number
+//	},
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7)
+	}
+};
+
+static struct gpio_led_platform_data dp7050_led_data =
+{
+	.num_leds = ARRAY_SIZE(dp7050_led),
+	.leds     = dp7050_led,
+};
+
+static struct platform_device dp7050_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &dp7050_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET6226)
+static struct et6226_key dp7050_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+//	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+//	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et6226_character dp7050_front_panel_characters[] =
+{
+	ET6226_7_SEG_ASCII
+};
+
+static struct platform_device dp7050_front_panel =
+{
+	.name = "et6226",
+	.id = -1,
+	.dev.platform_data = &(struct et6226_platform_data)
+	{
+//		.gpio_din         = ET16315_DIN,
+//		.gpio_dout        = ET16315_DOUT,
+//		.gpio_clk         = ET16315_CLK,
+//		.gpio_stb         = ET16315_STB,
+		.digits           = 4,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(dp7050_front_panel_keys),
+		.keys             = dp7050_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(dp7050_front_panel_characters),
+		.characters       = dp7050_front_panel_characters
+		.text             = "7050",
+	},
+};
+
+static struct gpio_keys_button dp7050_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = DP7050_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device dp7050_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &dp7050_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif  // INPUT_ET6226
+
+
+/* NAND Flash */
+/* The DP7050 main board is equipped with a 128 Mbyte AMD S34ML01G1 NAND flash memory */
+static struct stm_nand_bank_data dp7050_nand_flash =
+{  // TODO: insert 128Mbyte mtd layout
+	.csn            = 0,
+	.options        = NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions  = 9,
+	.partitions     = (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00300000          //   3 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x04000000,         // 64 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x07e00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 128 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x07e00000,         // 126 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec    = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp7050_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appear
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP7050_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP7050_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp7050_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25), /* MDINT */
+};
+
+static struct platform_device *dp7050_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&dp7050_leds,
+#endif
+#if defined(INPUT_ET6226)
+	&dp7050_front_panel,
+	&dp7050_fp_gpio_keys
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the various PIO's */
+#define SLEEP 500
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 2 && j == 6) || (i == 2 && j == 7) || (i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP7050_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP7050_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP7050_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP7050_POWER_ON, 0);
+
+	// jdc1004 '13.07.30 HW request, change to input mode
+	gpio_request(DP7050_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP7050_HDMI);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode = stxh205_ethernet_mode_mii,
+		.ext_clk = 1,
+		.phy_bus = 0,
+		.phy_addr = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+//	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1,
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6,
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCL:2.6, SDA:2.7
+//		.routing.ssc5.sclk = stxh205_ssc5_sclk_pio2_6,
+//		.routing.ssc5.mtsr = stxh205_ssc5_mtsr_pio2_7
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc = 0,
+		.no_mmc_boot_data_error = 1,
+	});
+
+#if 0
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(DP7050_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(DP7050_GPIO_FLASH_WP, 1);
+#endif
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp7050_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(dp7050_devices, ARRAY_SIZE(dp7050_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *dp7050_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv = {
+	.mv_name = "dp7050",
+	.mv_setup = dp7050_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = dp7050_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+//static int dp7050_board_freeze(struct stm_wakeup_devices *wkd)
+static int dp7050_board_freeze(void)
+{
+//	if (!wkd->stm_mac0_can_wakeup)
+		gpio_set_value(DP7050_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+//static int dp7050_board_defrost(struct stm_wakeup_devices *wkd)
+static int dp7050_board_defrost(void)
+{
+	dp7050_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board dp7050_hom =
+{
+	.freeze = dp7050_board_freeze,
+	.restore = dp7050_board_defrost,
+};
+
+static int __init dp7050_hom_register(void)
+{
+	return stm_hom_board_register(&dp7050_hom);
+}
+
+module_init(dp7050_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-ep8000/Makefile.orig
+++ b/arch/sh/boards/mach-ep8000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis EP8000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-ep8000/setup.c.orig
+++ b/arch/sh/boards/mach-ep8000/setup.c
@@ -0,0 +1,524 @@
+/*
+ * arch/sh/boards/mach-ep8000/setup.c
+ *
+ * Modified for Fortis EP8000 board by Audioniek,
+ * based on arch/sh/boards/mach-b2064/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2011 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define EP8000_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define EP8000_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 // TODO: get correct value
+
+// EP8000 specific changes
+#define EP8000_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+//#define SMARTCARD1_0             stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1             stm_gpio(11, 1)
+
+//#define ep8000_GPIO_FLASH_WP		stm_gpio(6, 2)
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init ep8000_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis EP8000 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN702
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led ep8000_led[] =
+{
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7)
+	}
+};
+
+static struct gpio_led_platform_data ep8000_led_data =
+{
+	.num_leds = ARRAY_SIZE(ep8000_led),
+	.leds     = ep8000_led,
+};
+
+static struct platform_device ep8000_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &ep8000_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key ep8000_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character ep8000_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device ep8000_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(ep8000_front_panel_keys),
+		.keys             = ep8000_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(ep8000_front_panel_characters),
+		.characters       = ep8000_front_panel_characters
+		.text             = "EP8000",
+	},
+};
+
+static struct gpio_keys_button ep8000_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = EP8000_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device ep8000_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &ep8000_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The EP8000 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data ep8000_nand_flash =
+{
+	.csn            = 0,
+	.options        = NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions  = 9,
+	.partitions     = (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec    = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int ep8000_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(EP8000_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(EP8000_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id         = 0,
+	.phy_reset      = ep8000_phy_reset,
+	.phy_mask       = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *ep8000_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&ep8000_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&ep8000_keys,
+	&ep8000_front_panel,
+	&ep8000_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 500
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(EP8000_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(EP8000_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(EP8000_POWER_ON, "POWER_ON");
+	gpio_direction_output(EP8000_POWER_ON, 0);
+
+	gpio_request(EP8000_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(EP8000_HDMI);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+#if 0
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(ep8000_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(ep8000_GPIO_FLASH_WP, 1);
+#endif
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &ep8000_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(ep8000_devices, ARRAY_SIZE(ep8000_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *ep8000_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2064 __initmv =
+{
+	.mv_name = "ep8000",
+	.mv_setup = ep8000_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = ep8000_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int ep8000_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+	{
+		gpio_set_value(EP8000_GPIO_POWER_ON_ETH, 0);
+	}
+	return 0;
+}
+
+static int ep8000_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	ep8000_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board ep8000_hom =
+{
+	.freeze  = ep8000_board_freeze,
+	.restore = ep8000_board_defrost,
+};
+
+static int __init ep8000_hom_register(void)
+{
+	return stm_hom_board_register(&ep8000_hom);
+}
+
+module_init(ep8000_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-epp8000/Makefile.orig
+++ b/arch/sh/boards/mach-epp8000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis EPP8000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-epp8000/setup.c.orig
+++ b/arch/sh/boards/mach-epp8000/setup.c
@@ -0,0 +1,524 @@
+/*
+ * arch/sh/boards/mach-epp8000/setup.c
+ *
+ * Modified for Fortis EPP8000 board by Audioniek,
+ * based on arch/sh/boards/mach-b2064/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2011 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define EPP8000_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define EPP8000_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND               1 // TODO: get correct value
+
+// EPP8000 specific changes
+#define EPP8000_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN               stm_gpio(14, 4)
+#define ET16315_DOUT              stm_gpio(14, 5)
+#define ET16315_CLK               stm_gpio(14, 6)
+#define ET16315_STB               stm_gpio(14, 7)
+#endif
+//#define SMARTCARD1_0              stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1              stm_gpio(11, 1)
+
+//#define EPP8000_GPIO_FLASH_WP		stm_gpio(6, 2)
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init epp8000_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis EPP8000 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN702
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led epp8000_led[] =
+{
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7)
+	}
+};
+
+static struct gpio_led_platform_data epp8000_led_data =
+{
+	.num_leds = ARRAY_SIZE(epp8000_led),
+	.leds     = epp8000_led,
+};
+
+static struct platform_device epp8000_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &epp8000_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key epp8000_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character epp8000_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device epp8000_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(epp8000_front_panel_keys),
+		.keys             = epp8000_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(epp8000_front_panel_characters),
+		.characters       = epp8000_front_panel_characters
+		.text             = "EPP8000",
+	},
+};
+
+static struct gpio_keys_button epp8000_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = EPP8000_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device epp8000_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &epp8000_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The EPP8000 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data epp8000_nand_flash =
+{
+	.csn            = 0,
+	.options        = NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions  = 9,
+	.partitions     = (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec    = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int epp8000_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(EPP8000_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(EPP8000_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id         = 0,
+	.phy_reset      = epp8000_phy_reset,
+	.phy_mask       = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *epp8000_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&epp8000_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&epp8000_keys,
+	&epp8000_front_panel,
+	&epp8000_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 500
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(EPP8000_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(EPP8000_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(EPP8000_POWER_ON, "POWER_ON");
+	gpio_direction_output(EPP8000_POWER_ON, 0);
+
+	gpio_request(EPP8000_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(EPP8000_HDMI);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH26PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+#if 0
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(EPP8000_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(EPP8000_GPIO_FLASH_WP, 1);
+#endif
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &epp8000_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(epp8000_devices, ARRAY_SIZE(epp8000_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *epp8000_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2064 __initmv =
+{
+	.mv_name = "epp8000",
+	.mv_setup = epp8000_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = epp8000_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int epp8000_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+	{
+		gpio_set_value(EPP8000_GPIO_POWER_ON_ETH, 0);
+	}
+	return 0;
+}
+
+static int epp8000_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	epp8000_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board epp8000_hom =
+{
+	.freeze  = epp8000_board_freeze,
+	.restore = epp8000_board_defrost,
+};
+
+static int __init epp8000_hom_register(void)
+{
+	return stm_hom_board_register(&epp8000_hom);
+}
+
+module_init(epp8000_hom_register);
+#endif
+// vim:ts=4--- a/arch/sh/boards/mach-fx6010/Makefile.orig
+++ b/arch/sh/boards/mach-fx6010/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis FX6010 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-fx6010/setup.c.orig
+++ b/arch/sh/boards/mach-fx6010/setup.c
@@ -0,0 +1,527 @@
+/*
+ * arch/sh/boards/mach-fx6010/setup.c
+ *
+ * Modified for Fortis FX6010 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET6226)
+#include <linux/et6226.h>
+#include <linux/i2c.h>
+#endif
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define FX6010_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define FX6010_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 //TODO: get correct value
+
+// FX6010 specific changes
+#define FX6010_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET6226)
+#define ET6226_I2C_SCL           stm_gpio(2, 6)
+#define ET6226_I2C_SDA           stm_gpio(2, 7)
+#endif
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - companion 0? (4mb) 
+0x40400000 - 0x404fffff - companion 1? (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x42dd1fff - bigphys ( 30mb)
+//0x4A000000 - 0x4FBFFFFF - lmi_io  ( 92mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x40fd2000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x4a000000,
+		.size  = 0x20000000,  /* 92 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init fx6010_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis FX6010 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN701
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led fx6010_led[] =
+{
+	{
+		.name = "LED_GREEN",
+		.gpio = stm_gpio(13, 2)
+	},
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7)
+	}
+};
+
+static struct gpio_led_platform_data fx6010_led_data =
+{
+	.num_leds	= ARRAY_SIZE(fx6010_led),
+	.leds		= fx6010_led
+};
+
+static struct platform_device fx6010_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &fx6010_led_data,
+	}
+};
+#endif
+
+#if defined(INPUT_ET6226)
+static struct et6226 key fx6010 front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" }
+};
+
+static struct et6226_character fx6010_front_panel_characters[] =
+{
+	ET6226_7_SEG_ASCII
+};
+
+static struct platform_device fx6010_front_panel =
+{
+	.name = "et6226",
+	.id   = -1,
+	.dev.platform_data = &(struct et6226_platform_data)
+	{
+		.gpio_scl         = ET6226_I2C_SCL,
+		.gpio_sda         = ET6226_I2C_SDA,
+		.digits           = 4,
+
+		.keys_num         = ARRAY_SIZE(fx6010_front_panel_keys),
+		.keys             = fx6010_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(fx6010_front_panel_characters),
+		.characters       = fx6010_front_panel_characters
+		.text             = "6010",
+	},
+};
+
+static struct gpio_keys_button fx6010_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = FX6010_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device fx6010_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &fx6010_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The FX6010 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data fx6010_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8       This is the config actually used
+			.offset = 0x0fe00000,         // 254 Mbyte  by the factory firmware
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int fx6010_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(FX6010_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(FX6010_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id         = 0,
+	.phy_reset      = fx6010_phy_reset,
+	.phy_mask       = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *fx6010_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&fx6010_leds,
+#endif
+#if defined(INPUT_ET6226)
+	&fx6010_keys,
+	&fx6010_front_panel,
+ 	&fx6010_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 1
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 500
+	int i, j;
+
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 2 && j == 6) || (i == 2 && j == 7) || (i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d,%1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+//				mdelay(SLEEP);
+//				mdelay(SLEEP);
+//				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(FX6010_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(FX6010_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(FX6010_POWER_ON, "POWER_ON");
+	gpio_direction_output(FX6010_POWER_ON, 0);
+
+	gpio_request(FX6010_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(FX6010_HDMI);
+	
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCDL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{ // LNB PIO SCDL:9.4, SDA:9.5
+
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+#if 1 // defined(INPUT_ET6226)
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCDL:2.6, SDA:2.7
+//TODO:		.routing.ssc5.sclk = stxh205_ssc5_sclk_pio2_6,
+//		.routing.ssc5.mtsr = stxh205_ssc5_mtsr_pio2_7
+	});
+#endif
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+#if defined(CONFIG_LIRC_STM_UHF)
+		.rx_mode       = stxh205_lirc_rx_mode_uhf,
+#else
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+#endif
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &fx6010_nand_flash,
+		.rbn.flex_connected = 1,
+//		.bch_ecc_cfg        = BCH_ECC_CFG_NOECC
+	});
+
+	return platform_add_devices(fx6010_devices, ARRAY_SIZE(fx6010_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *fx6010_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv =
+{
+	.mv_name       = "fx6010",
+	.mv_setup      = fx6010_setup,
+	.mv_nr_irqs    = NR_IRQS,
+	.mv_ioport_map = fx6010_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(void)
+{
+	gpio_set_value(FX6010_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(void)
+{
+	fx6010_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom =
+{
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-gpv8000/Makefile.orig
+++ b/arch/sh/boards/mach-gpv8000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis GPV8000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-gpv8000/setup.c.orig
+++ b/arch/sh/boards/mach-gpv8000/setup.c
@@ -0,0 +1,517 @@
+/*
+ * arch/sh/boards/mach-gpv8000/setup.c
+ *
+ * Modified for Fortis GPV8000 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define GPV8000_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define GPV8000_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND               1 // TODO: get correct value
+
+// GPV8000 specific changes
+#define GPV8000_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+//#define SMARTCARD1_0             stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1             stm_gpio(11, 1)
+
+//#if 0
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init gpv8000_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis GPV8000 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN702
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led gpv8000_led[] =
+{
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7),
+	}
+};
+
+static struct gpio_led_platform_data gpv8000_led_data =
+{
+	.num_leds = ARRAY_SIZE(gpv8000_led),
+	.leds     = gpv8000_led,
+};
+
+static struct platform_device gpv8000_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &gpv8000_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key gpv8000_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character gpv8000_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device gpv8000_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(gpv8000_front_panel_keys),
+		.keys             = gpv8000_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(gpv8000_front_panel_characters),
+		.characters       = gpv8000_front_panel_characters
+		.text             = "GPV8000",
+	},
+};
+
+static struct gpio_keys_button gpv8000_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = GPV8000_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device gpv8000_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &gpv8000_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The GPV8000 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data gpv8000_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec    = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int gpv8000_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(GPV8000_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(GPV8000_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = gpv8000_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *gpv8000_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&gpv8000_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&gpv8000_keys,
+	&gpv8000_front_panel,
+ 	&gpv8000_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 500
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(GPV8000_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(GPV8000_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(GPV8000_POWER_ON, "POWER_ON");
+	gpio_direction_output(GPV8000_POWER_ON, 0);
+
+	gpio_request(GPV8000_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(GPV8000_HDMI);
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+#if 0
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+#endif
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &gpv8000_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(gpv8000_devices, ARRAY_SIZE(gpv8000_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *gpv8000_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_gpv8000 __initmv =
+{
+	.mv_name = "gpv8000",
+	.mv_setup = gpv8000_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = gpv8000_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int gpv8000_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+	{
+		gpio_set_value(GPV8000_GPIO_POWER_ON_ETH, 0);
+	}
+	return 0;
+}
+
+static int gpv8000_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	gpv8000_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board gpv8000_hom =
+{
+	.freeze  = gpv8000_board_freeze,
+	.restore = gpv8000_board_defrost,
+};
+
+static int __init gpv8000_hom_register(void)
+{
+	return stm_hom_board_register(&gpv8000_hom);
+}
+
+module_init(gpv8000_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/Makefile.orig
+++ b/arch/sh/Makefile
@@ -204,6 +204,16 @@
 machdir-$(CONFIG_SH_ST_MB839)			+= mach-mb839
 machdir-$(CONFIG_SH_ST_MB903)			+= mach-mb903
 
+# Fortis boards
+machdir-$(CONFIG_SH_FORTIS_DP2010)		+= mach-dp2010
+machdir-$(CONFIG_SH_FORTIS_DP7000)		+= mach-dp7000
+machdir-$(CONFIG_SH_FORTIS_DP7001)		+= mach-dp7001
+machdir-$(CONFIG_SH_FORTIS_DP7050)		+= mach-dp7050
+machdir-$(CONFIG_SH_FORTIS_EP8000)		+= mach-ep8000
+machdir-$(CONFIG_SH_FORTIS_EPP8000)		+= mach-epp8000
+machdir-$(CONFIG_SH_FORTIS_FX6010)		+= mach-fx6010
+machdir-$(CONFIG_SH_FORTIS_GPV8000)		+= mach-gpv8000
+
 ifneq ($(machdir-y),)
 core-y	+= $(addprefix arch/sh/boards/, \
 	     $(filter-out ., $(patsubst %,%/,$(machdir-y))))
